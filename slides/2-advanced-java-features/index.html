<!doctype html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced Java features</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/theme/white.css" crossorigin="anonymous" id="theme">
    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/search/search.js"></script>
    <script src="/slides/script.js" type="module"></script>
    <link rel="stylesheet" href="/css/solarized-light.css" />
    <link rel="stylesheet" href="/slides/style.css">

    <script src="/fontawesome-6.4.2/js/all.min.js"></script>
</head>

<body>

    <div class="reveal">
        <div class="slides">
            <!-- Title and outline -->
            <section data-background="#333333">
                <h2>AMT</h2>
                <h1>Advanced Java features</h1>
                <p>Bertil Chapuis</p>
            </section>
            <section data-markdown>
                <textarea data-template>
                    ## <i class="fas fa-tasks"></i> Overview of Today's Class

                    Java runtimes for multi-tier applications often rely on advanced Java features such as:

                    - Class loaders
                    - Reflection
                    - Proxies
                    - Runtime annotations
                    - Compile-time annotations

                    Today, we will explore these features in detail and see how they can be used in practice.

                </textarea>
            </section>

            <!-- Class loaders -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Class loaders</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Class loaders

                        Class loaders are responsible for loading classes into the JVM at runtime.

                        The main class loaders are:
                        - Bootstrap class loader: Loads classes from the JVM's core library ($JAVA_HOME/lib/)
                        - Extension class loader: Loads classes from the JVM's extension library ($JAVA_HOME/lib/ext/)
                        - Application class loader: Loads classes from the classpath (.)

                        When a class is not found by the application class loader, the class loader will recursively delegate the loading of the class to the parent class loader until the bootstrap class loader is reached.

                        If the class is not found through the entire delegation chain, the class loader will throw a `ClassNotFoundException`.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Examples

                        Finding the class loader of a class:

                        ```java
                        System.out.println(MyClass.class.getClassLoader()); // AppClassLoader (application class loader)
                       System.out.println(DriverManager.class.getClassLoader()); // PlatformClassLoader (extension class loader)
                       System.out.println(String.class.getClassLoader()); // null (bootstrap class loader)
                       ```

                       Examining the delegation chain in a stack trace:

                       ```java
                       Class<?> clazz = Class.forName("ch.heigvd.amt.MyClass");
                       ```

                       ```
                       Exception in thread "main" java.lang.ClassNotFoundException: com.example.MyClass
                       at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)
                       at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
                       at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
                       at java.base/java.lang.Class.forName0(Native Method)
                       at java.base/java.lang.Class.forName(Class.java:375)
                       at Main.main(Main.java:6)
                       ```

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Creating a custom class loader

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Creating a custom delegation chain

                    </textarea>
                </section>


                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        Changing the default class loader at startup:

                        ```
                        java -Djava.system.class.loader=com.example.MyClassLoader com.example.Main
                        ```

                        Changing the default class loader programmatically:

                        ```
                        Thread.currentThread().setContextClassLoader(classLoader);
                        ```

                        A thread factory can be used to create new threads with a custom class loader.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Custom class loaders

                    </textarea>
                </section>

            </section>

            <!-- Advanced Java Features -->
            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Reflection</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Reflection

                        Reflection refers to the ability of a program to inspect and modify its structure and behavior at runtime.

                        In multitier applications, reflection is often used to:
                        - Dynamically load classes
                        - Dynamically create objects
                        - Dynamically invoke methods
                        - Dynamically access fields
                        - Code generation


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Reflection API

                        Java provides a rich Reflection API in the `java.lang.reflect` package:

                        - `Class<?>`: Represents classes and interfaces in a running Java application
                        - `Method`: Provides information about, and access to, a single method on a class or interface
                        - `Field`: Provides information about, and dynamic access to, a single field of a class or interface
                        - `Constructor`: Provides information about, and access to, a single constructor for a class

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">

                        ## Example of using the Reflection API

                        ```java
                        import java.lang.reflect.*;

                        // Instantiate an object
                        Class<?> clazz = Class.forName("com.example.MyClass");
                        Object object = clazz.newInstance();

                        // Invoke a method of the object
                        Method method = clazz.getMethod("myMethod");
                        method.invoke(object);

                        // Set an object's field with a given value
                        Field field = clazz.getField("myField");
                        field.set(object, "myValue");
                        ```

                        Consult the Java documentation for more information:
                        https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-summary.html
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Reflection and object-oriented programming

                        While it provides great flexibility, reflection can also break some of the core principles of object-oriented programming:

                        - Encapsulation: Reflection allows access to private fields and methods, which can violate encapsulation.
                        - Inheritance: Reflection can bypass the normal inheritance hierarchy, leading to potential issues with method resolution.
                        - Polymorphism: Reflection can make the behavior of methods unpredictable, as it does not follow the usual method resolution order.

                        Therefore, these features should be used with caution.

                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Reflection</h2>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Proxies

                        A proxy is an object that acts as an interface to another object.

                        In multitier applications, proxies are often used to:
                        - Intercept method calls
                        - Add behavior to method calls
                        - Implement lazy loading
                        - Implement caching
                        - Implement transactions
                        - Implement security checks


                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        A simple interface and its implementation.
                        ```java
                        interface MyInterface {
                            void myMethod();
                        }

                        class MyInterfaceImpl implements MyInterface {
                            @Override
                            public void myMethod() {
                                System.out.println("Hello World!");
                            }
                        }
                        ```
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.7em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ```java
                        import java.lang.reflect.*;

                        // Assuming here MyInterface and MyInterfaceImpl definitions

                        public class MyInvocationHandler implements InvocationHandler {
                            private final Object target;
        
                            public MyInvocationHandler(Object target) {
                                this.target = target;
                            }
        
                            @Override
                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                System.out.println("Before method call");
                                Object result = method.invoke(target, args);
                                System.out.println("After method call");
                                return result;
                            }
                        }

                        public class App {
                            public static void main(String[] args) {
                                MyInterface object = new MyInterfaceImpl();
                                MyInvocationHandler handler = new MyInvocationHandler(object);
                                MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                                    MyInterface.class.getClassLoader(),
                                    new Class[] { MyInterface.class },
                                    handler
                                );
                                proxy.myMethod();
                            }
                        }
                        ```
                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Runtime annotations</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Runtime annotations

                        Annotations are a form of metadata that can be added to Java classes, methods, and fields.

                        In multitier applications, annotations are often used to:
                        - Implement dependency injection
                        - Implement persistence
                        - Implement validation
                        - Implement security checks

                        Annotations can be read at runtime using reflection.

                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        Processing annotations at runtime of application.
                        ```java
                        import java.lang.annotation.*;

                        @Retention(RetentionPolicy.RUNTIME)
                        @Target(ElementType.TYPE)
                        @interface MyAnnotation {
                            String value();
                        }

                        @MyAnnotation("Hello World!")
                        class MyClass {
                        }

                        public class MyAnnotationProcessor {
                            public static void main(String[] args) {
                                Class<?> clazz = Class.forName("com.example.MyClass");
                                MyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);
                                System.out.println(annotation.value());
                            }
                        }
                        ```
                    </textarea>
                </section>
            </section>

            <section>
                <section data-background="#333333">
                    <h2><i class="fas fa-sitemap"></i> Compile-time annotations</h2>
                </section>
                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        ## Compile-time annotations

                        Annotations can also be used at compile-time to generate code.

                        Recently compile-time annotations have been used as a mean to accelerate the startup time of large Java applications.

                        A significant amount of time was spent at startup to introspect the code base, load and initialize classes.

                        Compile-time annotations must be processed by a compiler plugin called an annotation processor.

                        Both the compile-time annotations and the annotation processor must be compiled and added to the classpath of the compiler.

                        Notes:
                        Examples of compile-time annotations improving startup of Java applications:
                        * https://dagger.dev/ (dependency injection)
                        * https://projectlombok.org/ (generation of boilerplate code)
                        * https://mapstruct.org/ (generate mappers)
                    </textarea>
                </section>

                <section data-markdown style="font-size: 0.8em;">
                    <textarea data-template data-separator-notes="^Notes:">
                        Implementation stub of compile-time annotations processor.
                        ```java
                        import javax.annotation.processing.*;
                        import javax.lang.model.SourceVersion;
                        import javax.lang.model.element.*;
                        import javax.lang.model.type.TypeMirror;

                        @SupportedAnnotationTypes("mypackage.MyAnnotation")
                        @SupportedSourceVersion(SourceVersion.RELEASE_8)
                        public class MyAnnotationProcessor extends AbstractProcessor {

                            @Override
                            public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
                                // process the annotation and generate code
                                return true;
                            }
                        }
                        ```
                    </textarea>
                </section>


            </section>

            <section>
                <h2><i class="fas fa-hand-paper"></i> Questions?</h2>
            </section>

        </div>
    </div>

</body>

</html>